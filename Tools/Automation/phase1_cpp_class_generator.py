#!/usr/bin/env python3
"""
Terminal Grounds Phase 1 C++ Class Generator
DevOps Automation System for UE5 Class Creation
"""

import os
import sys
import json
import shutil
import subprocess
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional, Tuple

class UE5ClassGenerator:
    """Automated C++ class generation for Terminal Grounds Phase 1"""
    
    def __init__(self, project_root: str):
        self.project_root = Path(project_root)
        self.source_root = self.project_root / "Source"
        self.templates_dir = self.project_root / "Tools" / "Automation" / "Templates"
        self.generated_classes = []
        
    def generate_class(self, module_name: str, class_name: str, 
                      class_type: str = "UObject", 
                      parent_class: str = "UObject",
                      includes: List[str] = None) -> bool:
        """Generate C++ header and implementation files"""
        
        if includes is None:
            includes = ["CoreMinimal.h"]
            
        # Determine module directory
        module_dir = self.source_root / module_name
        if not module_dir.exists():
            print(f"ERROR: Module {module_name} not found in Source directory")
            return False
            
        # Generate header file
        header_success = self._generate_header(
            module_dir, class_name, class_type, parent_class, includes
        )
        
        # Generate implementation file
        impl_success = self._generate_implementation(
            module_dir, class_name, class_type
        )
        
        # Update module build file
        build_success = self._update_build_file(module_dir, class_name)
        
        success = header_success and impl_success and build_success
        
        if success:
            self.generated_classes.append({
                "module": module_name,
                "class": class_name,
                "type": class_type,
                "timestamp": datetime.now().isoformat()
            })
            print(f"SUCCESS: Generated {class_name} in module {module_name}")
        else:
            print(f"FAILED: Error generating {class_name}")
            
        return success
    
    def _generate_header(self, module_dir: Path, class_name: str, 
                        class_type: str, parent_class: str,
                        includes: List[str]) -> bool:
        """Generate C++ header file"""
        
        public_dir = module_dir / "Public"
        if not public_dir.exists():
            public_dir.mkdir(parents=True, exist_ok=True)
            
        header_path = public_dir / f"{class_name}.h"
        
        # Header template
        header_content = f'''#pragma once

#include "CoreMinimal.h"
{chr(10).join(f'#include "{include}"' for include in includes if include != "CoreMinimal.h")}
#include "{class_name}.generated.h"

/**
 * {class_name} - Terminal Grounds Phase 1 Implementation
 * Generated by DevOps Automation System
 * Timestamp: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
 */
UCLASS(BlueprintType, Blueprintable)
class TGCORE_API {class_name} : public {parent_class}
{{
    GENERATED_BODY()

public:
    {class_name}();

protected:
    virtual void BeginPlay() override;

public:
    virtual void Tick(float DeltaTime) override;

protected:
    // Phase 1 Core Functionality
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Terminal Grounds")
    bool bIsInitialized = false;
    
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Terminal Grounds")
    FString ComponentID;

private:
    // Internal state management
    float LastUpdateTime;
    
    // Phase 1 Performance Metrics
    UPROPERTY()
    int32 UpdateCount = 0;
}};
'''
        
        try:
            with open(header_path, 'w', encoding='utf-8') as f:
                f.write(header_content)
            return True
        except Exception as e:
            print(f"ERROR: Failed to write header file: {e}")
            return False
    
    def _generate_implementation(self, module_dir: Path, class_name: str, class_type: str) -> bool:
        """Generate C++ implementation file"""
        
        private_dir = module_dir / "Private"
        if not private_dir.exists():
            private_dir.mkdir(parents=True, exist_ok=True)
            
        impl_path = private_dir / f"{class_name}.cpp"
        
        # Implementation template
        impl_content = f'''#include "{class_name}.h"
#include "Engine/Engine.h"
#include "Components/ActorComponent.h"

{class_name}::{class_name}()
{{
    PrimaryActorTick.bCanEverTick = true;
    PrimaryActorTick.bStartWithTickEnabled = true;
    
    // Phase 1 Initialization
    bIsInitialized = false;
    ComponentID = FString::Printf(TEXT("{class_name}_%d"), FMath::Rand());
    LastUpdateTime = 0.0f;
    
    // Performance optimization for Phase 1
    SetTickInterval(0.016f); // 60 FPS target
}}

void {class_name}::BeginPlay()
{{
    Super::BeginPlay();
    
    // Phase 1 Component Initialization
    bIsInitialized = true;
    LastUpdateTime = GetWorld()->GetTimeSeconds();
    
    // DevOps monitoring integration
    UE_LOG(LogTemp, Log, TEXT("Phase 1 Component %s initialized at %f"), 
           *ComponentID, LastUpdateTime);
}}

void {class_name}::Tick(float DeltaTime)
{{
    Super::Tick(DeltaTime);
    
    if (!bIsInitialized)
        return;
        
    // Phase 1 Performance Tracking
    UpdateCount++;
    LastUpdateTime = GetWorld()->GetTimeSeconds();
    
    // Automated performance monitoring
    if (UpdateCount % 3600 == 0) // Log every minute at 60fps
    {{
        UE_LOG(LogTemp, Verbose, TEXT("Phase 1 Component %s: %d updates completed"), 
               *ComponentID, UpdateCount);
    }}
}}
'''
        
        try:
            with open(impl_path, 'w', encoding='utf-8') as f:
                f.write(impl_content)
            return True
        except Exception as e:
            print(f"ERROR: Failed to write implementation file: {e}")
            return False
    
    def _update_build_file(self, module_dir: Path, class_name: str) -> bool:
        """Update module Build.cs file to include new dependencies if needed"""
        
        build_file = module_dir / f"{module_dir.name}.Build.cs"
        if not build_file.exists():
            print(f"WARNING: Build file not found: {build_file}")
            return True  # Non-critical for basic class generation
            
        try:
            # For now, just validate the build file exists
            # In production, would parse and update dependencies
            return True
        except Exception as e:
            print(f"ERROR: Failed to update build file: {e}")
            return False
    
    def generate_phase1_core_classes(self) -> bool:
        """Generate essential Phase 1 classes for foundational playability"""
        
        # Core gameplay classes for Phase 1
        core_classes = [
            {
                "module": "TGCore", 
                "class": "TGPlayerController", 
                "type": "APlayerController",
                "parent": "APlayerController",
                "includes": ["Engine/PlayerController.h"]
            },
            {
                "module": "TGCore",
                "class": "TGGameMode", 
                "type": "AGameModeBase",
                "parent": "AGameModeBase",
                "includes": ["Engine/GameModeBase.h"]
            },
            {
                "module": "TGCore",
                "class": "TGCharacterBase",
                "type": "ACharacter", 
                "parent": "ACharacter",
                "includes": ["Engine/Character.h"]
            },
            {
                "module": "TGWorld",
                "class": "TGTerritorialZone",
                "type": "AActor",
                "parent": "AActor", 
                "includes": ["Engine/Actor.h"]
            },
            {
                "module": "TGCombat",
                "class": "TGWeaponSystem",
                "type": "UActorComponent",
                "parent": "UActorComponent",
                "includes": ["Components/ActorComponent.h"]
            }
        ]
        
        success_count = 0
        for class_def in core_classes:
            if self.generate_class(
                class_def["module"],
                class_def["class"],
                class_def["type"],
                class_def["parent"],
                class_def["includes"]
            ):
                success_count += 1
        
        print(f"Generated {success_count}/{len(core_classes)} Phase 1 core classes")
        return success_count == len(core_classes)
    
    def run_automated_build(self) -> bool:
        """Trigger automated build process"""
        
        # Use MSBuild for automated compilation
        sln_path = self.project_root / "TerminalGrounds.sln"
        if not sln_path.exists():
            print("ERROR: Solution file not found for automated build")
            return False
            
        try:
            cmd = [
                "MSBuild", 
                str(sln_path),
                "/p:Configuration=Development",
                "/p:Platform=Win64",
                "/m"  # Multi-processor build
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode == 0:
                print("SUCCESS: Automated build completed")
                return True
            else:
                print(f"BUILD FAILED: {result.stderr}")
                return False
                
        except Exception as e:
            print(f"ERROR: Build process failed: {e}")
            return False
    
    def generate_automation_report(self) -> Dict:
        """Generate DevOps automation report"""
        
        return {
            "timestamp": datetime.now().isoformat(),
            "project_root": str(self.project_root),
            "classes_generated": len(self.generated_classes),
            "generated_classes": self.generated_classes,
            "automation_status": "Phase 1 DevOps Implementation",
            "next_steps": [
                "Run automated build verification",
                "Execute UnrealMCP level creation automation", 
                "Deploy performance monitoring",
                "Initialize CI/CD pipeline"
            ]
        }

def main():
    """Phase 1 DevOps Automation Entry Point"""
    
    if len(sys.argv) < 2:
        print("Usage: python phase1_cpp_class_generator.py <project_root>")
        sys.exit(1)
        
    project_root = sys.argv[1]
    generator = UE5ClassGenerator(project_root)
    
    print("=== Terminal Grounds Phase 1 DevOps Automation ===")
    print("Automated C++ Class Generation System")
    print("")
    
    # Generate Phase 1 core classes
    if generator.generate_phase1_core_classes():
        print("SUCCESS: Phase 1 core classes generated")
        
        # Attempt automated build
        if generator.run_automated_build():
            print("SUCCESS: Automated build verification completed")
        else:
            print("WARNING: Build verification failed - manual intervention required")
            
        # Generate automation report
        report = generator.generate_automation_report()
        
        report_path = Path(project_root) / "phase1_automation_report.json"
        with open(report_path, 'w') as f:
            json.dump(report, f, indent=2)
            
        print(f"Automation report saved to: {report_path}")
        print("")
        print("=== Phase 1 DevOps Implementation Status ===")
        print(f"Classes Generated: {report['classes_generated']}")
        print("Ready for UnrealMCP level automation")
        print("Ready for performance monitoring deployment")
        
    else:
        print("FAILED: Phase 1 class generation incomplete")
        sys.exit(1)

if __name__ == "__main__":
    main()