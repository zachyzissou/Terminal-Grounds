"""
Terminal Grounds Documentation Generation Framework
Phase 3: Advanced Governance & Automation

Automated generation of documentation templates, reports, and quality metrics.
"""

# Import our validation framework functions (copied to avoid import issues)
import os
from pathlib import Path
from typing import Dict, List, Optional, Any, Tuple
from datetime import datetime
from dataclasses import dataclass
import logging

logger = logging.getLogger(__name__)

# Copy essential functions from validators
@dataclass
class ValidationResult:
    """Result of a validation check"""
    is_valid: bool
    errors: List[str]
    warnings: List[str]
    suggestions: List[str]

def get_all_markdown_files(docs_root: str = "../../docs") -> List[Path]:
    """Get all markdown files in the docs directory"""
    docs_path = Path(docs_root)
    return list(docs_path.rglob("*.md"))

def validate_all_documents(docs_root: str = "../../docs") -> Dict[str, ValidationResult]:
    """Validate all documents - simplified version for generation"""
    results = {}

    for md_file in get_all_markdown_files(docs_root):
        if md_file.name.lower() == "readme.md":
            continue

        # Simple validation - check if frontmatter exists
        try:
            with open(md_file, 'r', encoding='utf-8') as f:
                content = f.read()

            has_frontmatter = content.startswith('---')
            is_valid = has_frontmatter

            if is_valid:
                results[str(md_file.relative_to(docs_root))] = ValidationResult(True, [], [], [])
            else:
                results[str(md_file.relative_to(docs_root))] = ValidationResult(False, ["Missing frontmatter"], [], [])

        except Exception as e:
            results[str(md_file.relative_to(docs_root))] = ValidationResult(False, [f"Error reading file: {e}"], [], [])

    return results

@dataclass
class GenerationResult:
    """Result of a generation operation"""
    success: bool
    files_created: List[str]
    files_updated: List[str]
    errors: List[str]

class TemplateGenerator:
    """
    Generates documentation templates based on domain and type
    """

    def __init__(self, templates_dir: str = "templates"):
        self.templates_dir = Path(templates_dir)
        self.templates_dir.mkdir(exist_ok=True)

    def generate_frontmatter_template(self, domain: str, doc_type: str) -> str:
        """
        Generate standardized frontmatter template
        """
        template = f"""---
title: "Document Title"
type: "{doc_type}"
domain: "{domain}"
status: "draft"
last_reviewed: "{datetime.now().strftime('%Y-%m-%d')}"
maintainer: "Team Name"
tags:
  - "tag1"
  - "tag2"
related_docs:
  - "related_document.md"
---

# Document Title

## Overview

Brief description of the document's purpose and scope.

## Content

Document content goes here...

## References

- [Related Document 1](related_document.md)
- [Related Document 2](related_document2.md)

---
*Generated by Terminal Grounds Documentation Automation Framework*
"""

        return template

    def generate_domain_templates(self) -> GenerationResult:
        """
        Generate templates for all domain/type combinations
        """
        domains = ['technical', 'design', 'lore', 'art', 'process']
        types = ['guide', 'reference', 'process', 'spec', 'api']

        files_created = []
        errors = []

        for domain in domains:
            domain_dir = self.templates_dir / domain
            domain_dir.mkdir(exist_ok=True)

            for doc_type in types:
                template_name = f"{domain}_{doc_type}_template.md"
                template_path = domain_dir / template_name

                try:
                    template_content = self.generate_frontmatter_template(domain, doc_type)
                    with open(template_path, 'w', encoding='utf-8') as f:
                        f.write(template_content)

                    files_created.append(str(template_path))
                    logger.info(f"Created template: {template_path}")

                except Exception as e:
                    error_msg = f"Failed to create template {template_path}: {e}"
                    errors.append(error_msg)
                    logger.error(error_msg)

        return GenerationResult(
            success=len(errors) == 0,
            files_created=files_created,
            files_updated=[],
            errors=errors
        )

class ReportGenerator:
    """
    Generates quality reports and documentation metrics
    """

    def __init__(self, reports_dir: str = "reports"):
        self.reports_dir = Path(reports_dir)
        self.reports_dir.mkdir(exist_ok=True)

    def generate_quality_report(self, docs_root: str = "../../docs") -> GenerationResult:
        """
        Generate comprehensive quality report
        """
        logger.info("Generating quality report...")

        # Get validation results
        validation_results = validate_all_documents(docs_root)

        # Analyze results
        total_docs = len(validation_results)
        valid_docs = sum(1 for result in validation_results.values() if result.is_valid)
        invalid_docs = total_docs - valid_docs

        # Categorize issues
        missing_frontmatter = 0
        invalid_fields = 0
        cross_ref_issues = 0
        naming_issues = 0

        issue_details = []

        for doc_path, result in validation_results.items():
            if not result.is_valid:
                doc_issues = {
                    'path': doc_path,
                    'errors': result.errors,
                    'warnings': result.warnings,
                    'suggestions': result.suggestions
                }
                issue_details.append(doc_issues)

                # Categorize errors
                for error in result.errors:
                    if 'Missing frontmatter' in error:
                        missing_frontmatter += 1
                    elif 'Invalid' in error:
                        invalid_fields += 1
                    elif 'Related document not found' in error:
                        cross_ref_issues += 1
                    elif 'doesn\'t match' in error and 'pattern' in error:
                        naming_issues += 1

        # Generate report
        report_content = self._create_quality_report_content(
            total_docs, valid_docs, invalid_docs,
            missing_frontmatter, invalid_fields, cross_ref_issues, naming_issues,
            issue_details
        )

        # Save report
        report_path = self.reports_dir / f"quality_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"

        try:
            with open(report_path, 'w', encoding='utf-8') as f:
                f.write(report_content)

            return GenerationResult(
                success=True,
                files_created=[str(report_path)],
                files_updated=[],
                errors=[]
            )

        except Exception as e:
            return GenerationResult(
                success=False,
                files_created=[],
                files_updated=[],
                errors=[f"Failed to save quality report: {e}"]
            )

    def _create_quality_report_content(self, total_docs, valid_docs, invalid_docs,
                                     missing_frontmatter, invalid_fields, cross_ref_issues, naming_issues,
                                     issue_details) -> str:
        """
        Create the quality report content
        """
        success_rate = (valid_docs / total_docs * 100) if total_docs > 0 else 0

        report = f"""# Terminal Grounds Documentation Quality Report

**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## Executive Summary

- **Total Documents:** {total_docs}
- **Valid Documents:** {valid_docs}
- **Invalid Documents:** {invalid_docs}
- **Success Rate:** {success_rate:.1f}%

## Issue Breakdown

| Issue Type | Count | Percentage |
|------------|-------|------------|
| Missing Frontmatter | {missing_frontmatter} | {(missing_frontmatter/total_docs*100):.1f}% |
| Invalid Fields | {invalid_fields} | {(invalid_fields/total_docs*100):.1f}% |
| Cross-Reference Issues | {cross_ref_issues} | {(cross_ref_issues/total_docs*100):.1f}% |
| Naming Issues | {naming_issues} | {(naming_issues/total_docs*100):.1f}% |

## Detailed Issues

"""

        for issue in issue_details[:20]:  # Show first 20 issues
            report += f"### {issue['path']}\n\n"
            if issue['errors']:
                report += "**Errors:**\n"
                for error in issue['errors']:
                    report += f"- {error}\n"
            if issue['warnings']:
                report += "**Warnings:**\n"
                for warning in issue['warnings']:
                    report += f"- {warning}\n"
            if issue['suggestions']:
                report += "**Suggestions:**\n"
                for suggestion in issue['suggestions']:
                    report += f"- {suggestion}\n"
            report += "\n"

        if len(issue_details) > 20:
            report += f"*... and {len(issue_details) - 20} more issues*\n\n"

        report += """## Recommendations

1. **High Priority:** Add frontmatter to documents missing metadata
2. **Medium Priority:** Fix invalid field values (type, status, domain)
3. **Medium Priority:** Resolve cross-reference issues
4. **Low Priority:** Standardize naming conventions

## Next Steps

- Run validation regularly to track progress
- Use templates for new documents
- Implement automated frontmatter addition
- Set up continuous monitoring

---
*Generated by Terminal Grounds Documentation Automation Framework - Phase 3*
"""

        return report

class FrontmatterFixer:
    """
    Automatically adds or fixes frontmatter in documents
    """

    def __init__(self, docs_root: str = "../../docs"):
        self.docs_root = Path(docs_root)

    def fix_missing_frontmatter(self, domain: str = "process", doc_type: str = "reference") -> GenerationResult:
        """
        Add frontmatter to documents that are missing it
        """
        files_updated = []
        errors = []

        for md_file in get_all_markdown_files(str(self.docs_root)):
            if md_file.name.lower() == "readme.md":
                continue

            try:
                with open(md_file, 'r', encoding='utf-8') as f:
                    content = f.read()

                # Check if frontmatter exists
                if not content.startswith('---'):
                    # Generate frontmatter
                    title = md_file.stem.replace('_', ' ').title()
                    frontmatter = f"""---
title: "{title}"
type: "{doc_type}"
domain: "{domain}"
status: "draft"
last_reviewed: "{datetime.now().strftime('%Y-%m-%d')}"
maintainer: "Documentation Team"
tags: []
related_docs: []
---

"""

                    # Add frontmatter to content
                    new_content = frontmatter + content

                    # Write back
                    with open(md_file, 'w', encoding='utf-8') as f:
                        f.write(new_content)

                    files_updated.append(str(md_file))
                    logger.info(f"Added frontmatter to: {md_file}")

            except Exception as e:
                error_msg = f"Failed to fix frontmatter for {md_file}: {e}"
                errors.append(error_msg)
                logger.error(error_msg)

        return GenerationResult(
            success=len(errors) == 0,
            files_created=[],
            files_updated=files_updated,
            errors=errors
        )

# Main execution functions
def generate_templates() -> GenerationResult:
    """Generate all documentation templates"""
    generator = TemplateGenerator()
    return generator.generate_domain_templates()

def generate_quality_report() -> GenerationResult:
    """Generate quality report"""
    generator = ReportGenerator()
    return generator.generate_quality_report()

def fix_missing_frontmatter() -> GenerationResult:
    """Fix missing frontmatter in documents"""
    fixer = FrontmatterFixer()
    return fixer.fix_missing_frontmatter()

if __name__ == "__main__":
    print("🚀 Terminal Grounds Documentation Generation System")
    print("=" * 60)

    # Generate templates
    print("📝 Generating templates...")
    template_result = generate_templates()
    if template_result.success:
        print(f"✅ Created {len(template_result.files_created)} templates")
    else:
        print(f"❌ Template generation failed: {template_result.errors}")

    # Generate quality report
    print("\n📊 Generating quality report...")
    report_result = generate_quality_report()
    if report_result.success:
        print(f"✅ Created quality report: {report_result.files_created[0]}")
    else:
        print(f"❌ Report generation failed: {report_result.errors}")

    # Fix missing frontmatter
    print("\n🔧 Fixing missing frontmatter...")
    fix_result = fix_missing_frontmatter()
    if fix_result.success:
        print(f"✅ Fixed frontmatter in {len(fix_result.files_updated)} documents")
    else:
        print(f"❌ Frontmatter fixing failed: {fix_result.errors}")

    print("\n✅ Generation system operational!")
    print("🎯 Phase 3 automation tools ready for production!")
